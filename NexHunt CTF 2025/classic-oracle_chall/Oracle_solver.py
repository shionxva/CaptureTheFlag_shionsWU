import math
from functools import reduce

# Given data
n = 64097004224603491707013321855720791270082325408670028091396688270817416527102154051130968614204128733895217887782486437361878693991366560058694896363282049594271872695659379509797463255426572133624196626630801767486222156760410342028487400970632986125234454427456796297310753381504104736912158238896699008133

exponents = [
    5524628356033167723,
    162305599933585299,
    967145241284680197,
    1586071162376499,
    16450282068677304051,
    9424768547045024661,
    5305486005374470347,
    38342133878090663739,
    12458234985678922821,
    18374534319257443149
]

ciphertexts = [
    60927582001059466655742318783656781989891125805982614632129176105684194304897550638479738293349571746861326174982653936709416483978622659166487888918738198882858222794841400863902196688348372746682687153212776585821449114156659317181413819712072317700040460277677821481642269000619254620378583365834638196287,
    9470997986529180489332142707926176887563804571565563550022139856759716341127760694611756408462428569721334311816107284771493615344475723525408434525860409427047276683630575456251138885125614215307771031309536570347249570488028496957329056069404608581633176038999563138157219924740939860816444059837896481986,
    53959668594090328303207260771542190372725422483116932780904290377343538468988716418560463441146566700854477250265016886095794454191275187459500296059289987551235428714695765302693120303494977205023827174795480175606580764936512353583988812109124122245947223805782309928872758115869002673245927291355489483922,
    29833694385702623636015328772917834736075896986863036564301669230012758547829108876478231597198469906681737367654652733105175090859552608822283908544318112583342079404272047801225283680818845086070269731359671213342882956647120007095870920906575421058200725202223725438488931623777019194316165228338514463711,
    7675599596288685226628405828037150510338999006178583452236959586608544937060843353081361932206996371249634980460709901874388689325490872195350923769298984624257304689893864278346855709622881656634896969911109227655115926957579792798571094198849349868656445448271474931215949817336681484955292190662103316596,
    11975300229998020178768901119301982040788617920895532780862521599511777571051648149158374336648830136463320252716505549405593923351730487663728389520595336586627361651720586783062991240593400958186381398340014619017494885592944848563976310267284866888369622730617035491023968873682683859922538679520189294252,
    12537303644247113560286129613385909526557868700165437786005665420705706806077832875018280198585243826387666649750562371216203133440054611090937004343151578354579427411975451238041659486554300619417592001268450955893110942584321067474799596214640961023030962684262186011080047677091294017503025453423017938267,
    5591558247779226005143670198757276780748821515948844131875835102182914147363824346798744810583935608164921596572464274122729662093267284923401191266693508292704236209412964505298802173235945686590292240301781111791309151567244697936010183179214754257043488382206963172247155568304535232522531436783680298448,
    42584870724468545808196680874896421264878381586017942275123722488464721029680480340944955129852991808851799900155090228305135041201209010980021498203897003497920445056322923983498193118467531957117448062828561843337085195581699681268094598981103987834597206233471236576166458831603592243029548086392070243524,
    18841532078870627132719235282512367520850457305541362699042232237865053333653018554168177015273856346514418587682330872463989416573712520693488050688715775750819846848340266799368095877886328998600447531277539428553896045462551634178464925352148796397078331642635398186119477045441247861422277735695033855217
]

# Find GCD of all exponents
print("Computing GCD of all exponents...")
g = reduce(math.gcd, exponents)
print(f"GCD of all exponents: {g}")

# Now we can recover m^g mod n
# Since c_i = m^e_i mod n, we have c_i = (m^g)^(e_i/g) mod n

# Use extended GCD to find Bezout coefficients
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

# For two exponents e1 and e2 where gcd(e1, e2) = g
# We can write: a*e1 + b*e2 = g
# Then: c1^a * c2^b = m^(a*e1) * m^(b*e2) = m^(a*e1 + b*e2) = m^g mod n

e1, e2 = exponents[0], exponents[1]
gcd, a, b = extended_gcd(e1, e2)
print(f"\nUsing exponents e1={e1} and e2={e2}")
print(f"GCD: {gcd}")
print(f"Bezout coefficients: {a}*{e1} + {b}*{e2} = {gcd}")

# Compute m^gcd mod n
c1, c2 = ciphertexts[0], ciphertexts[1]
m_to_gcd = (pow(c1, a, n) * pow(c2, b, n)) % n
print(f"\nm^{gcd} mod n = {m_to_gcd}")

# Now we need to find the gcd-th root of m_to_gcd modulo n
# For small gcd, we can try to compute it directly
if gcd <= 100:
    # Try to find m such that m^gcd = m_to_gcd mod n
    # This requires factoring or using a root-finding algorithm
    print(f"\nNeed to find {gcd}-th root of {m_to_gcd} mod n")
    print("For small gcd, we can try various methods...")
    
    # If gcd is small enough, the message might be small too
    # Let's try computing the integer gcd-th root
    def integer_root(x, n):
        """Compute integer n-th root of x"""
        if x == 0:
            return 0
        high = 1
        while high ** n <= x:
            high *= 2
        low = high // 2
        while low < high:
            mid = (low + high) // 2
            if mid ** n < x:
                low = mid + 1
            else:
                high = mid
        return low
    
    # Try integer root (if m is small enough, m^gcd might not wrap around n)
    m_candidate = integer_root(m_to_gcd, gcd)
    print(f"\nCandidate m (integer root): {m_candidate}")
    
    # Verify
    if pow(m_candidate, gcd, n) == m_to_gcd:
        print(f"✓ Verification passed: m^{gcd} mod n matches!")
        print(f"\nRecovered m: {m_candidate}")
        
        # Convert to bytes and try to decode as flag
        try:
            m_bytes = m_candidate.to_bytes((m_candidate.bit_length() + 7) // 8, 'big')
            flag = m_bytes.decode('ascii', errors='ignore')
            print(f"Flag (ASCII): {flag}")
        except:
            print(f"Could not decode as ASCII")
            print(f"Flag (hex): {hex(m_candidate)}")
    else:
        print("✗ Verification failed, need different approach")